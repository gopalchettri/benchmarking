def get_criteria_prompt(control: str, subcontrol: str, framework: str) -> str:
    return (
        f'Control: {control}\n'
        f'Subcontrol: {subcontrol}\n\n'
        "Generate exactly three evaluation criteria for compliance assessment. "
        "Each criterion must be testable and actionable. "
        "Return ONLY a JSON array of three objects with this schema:\n\n"
        '[\n'
        '  {\n'
        '    "id": 1,                         # integer\n'
        '    "criterion": "short title",     # short sentence\n'
        '    "description": "one-paragraph detailed requirement",\n'
        '    "design_level": "what to look for at design level (short)",\n'
        '    "implementation_level": "what to look for at implementation level (short)",\n'
        '    "evidence_examples": ["e.g. meeting minutes", "e.g. list of parties"]\n'
        '  },\n'
        '  ... (total 3 objects)\n'
        ']\n\n'
        "Do not include any explanation, headings, markdown, or extra text. "
        "Do not output fewer or more than three objects."
    )

async def get_system_prompt(framework: str) -> str:
    """Production-grade system prompt with clear constraints."""
    return (
        f"You are an expert cybersecurity auditor specializing in {framework} compliance assessments.\n\n"
        f"CRITICAL REQUIREMENTS:\n"
        f"1. Output MUST be valid JSON only - no markdown, no explanations, no preamble\n"
        f"2. Output MUST be a JSON array with exactly 3 objects\n"
        f"3. Each object MUST have 'id' (integer) and 'criteria' (string) fields only\n"
        f"4. Write natural, professional language without escaped characters\n"
        f"5. Keep criteria concise: 40-60 words maximum per criterion\n\n"
        f"If you cannot generate valid JSON, return an empty array: []"
    )
async def get_criteria_prompt(control: str, subcontrol: str, framework: str) -> str:
    """Production-optimized prompt with clear structure and example."""
    return (
        f"Framework: {framework}\n"
        f"Control: {control}\n"
        f"Subcontrol: {subcontrol}\n\n"
        f"Task: Generate exactly 3 evaluation criteria for compliance assessment.\n\n"
        f"Structure for each criterion:\n"
        f"- Brief title (3-5 words)\n"
        f"- Core requirement description (1 sentence)\n"
        f"- Design-level check (1 sentence)\n"
        f"- Implementation-level check (1 sentence)\n\n"
        f"Combine all parts into ONE continuous string without labels.\n\n"
        f"EXAMPLE OUTPUT FORMAT:\n"
        f"[\n"
        f"  {{\n"
        f"    \"id\": 1,\n"
        f"    \"criteria\": \"Access Control Matrix - Define role-based permissions for all system resources. Verify comprehensive permission matrix exists in design documentation. Validate actual permissions match design specifications in production environment.\"\n"
        f"  }},\n"
        f"  {{\n"
        f"    \"id\": 2,\n"
        f"    \"criteria\": \"Authentication Mechanisms - Implement multi-factor authentication for privileged access. Review authentication flow diagrams and security architecture. Test MFA implementation across all access points.\"\n"
        f"  }},\n"
        f"  {{\n"
        f"    \"id\": 3,\n"
        f"    \"criteria\": \"Audit Logging Requirements - Maintain immutable audit logs for security events. Confirm logging strategy covers all security-relevant actions. Verify log integrity, retention, and monitoring capabilities.\"\n"
        f"  }}\n"
        f"]\n\n"
        f"Output ONLY the JSON array above with {framework} {control} {subcontrol} criteria. No additional text."
    )

async def get_system_prompt(framework: str) -> str:
    """
    Universal system prompt optimized for all benchmark models.
    Balanced complexity for fair comparison.
    """
    return (
        f"You are an expert cybersecurity compliance auditor specializing in {framework} standards.\n\n"
        f"Your task is to generate compliance evaluation criteria in strict JSON format.\n\n"
        f"OUTPUT REQUIREMENTS:\n"
        f"- Return ONLY a valid JSON array\n"
        f"- No markdown code blocks\n"
        f"- No explanations or additional text\n"
        f"- Each criterion must be clear, measurable, and actionable\n"
        f"- Each criterion must address both design-level and implementation-level verification\n"
    )
async def get_criteria_prompt(control: str, subcontrol: str, framework: str) -> str:
    """
    Universal user prompt for benchmarking all models.
    Optimized for clarity, consistency, and fair evaluation.
    """
    return (
        f"Framework: {framework}\n"
        f"Control: {control}\n"
        f"Subcontrol: {subcontrol}\n\n"
        
        f"Task: Generate exactly 3 compliance evaluation criteria.\n\n"
        
        f"Each criterion must:\n"
        f"1. Be clear and measurable\n"
        f"2. Focus on policy-level compliance (not technical implementation details)\n"
        f"3. Include a brief title (3-5 words)\n"
        f"4. State the core requirement\n"
        f"5. Specify design-level verification (what to check in documentation/plans)\n"
        f"6. Specify implementation-level verification (what to check in production systems)\n\n"
        
        f"Combine all parts into ONE continuous sentence per criterion.\n\n"
        
        f"EXAMPLE OUTPUT:\n"
        f"[\n"
        f"  {{\n"
        f"    \"id\": 1,\n"
        f"    \"criteria\": \"Access Control Matrix - Define comprehensive role-based permissions for all system resources. Verify that design documentation includes detailed permission matrix with role definitions. Validate that production systems enforce the defined permissions with quarterly access reviews.\"\n"
        f"  }},\n"
        f"  {{\n"
        f"    \"id\": 2,\n"
        f"    \"criteria\": \"Multi-Factor Authentication Policy - Implement MFA for all privileged accounts and remote access. Confirm that security architecture specifies MFA mechanisms and enrollment procedures. Verify MFA is configured on all access points with monitoring for authentication anomalies.\"\n"
        f"  }},\n"
        f"  {{\n"
        f"    \"id\": 3,\n"
        f"    \"criteria\": \"Security Audit Logging - Maintain comprehensive tamper-evident logs for all security events. Review logging strategy documentation covering log sources and retention requirements. Validate production logging captures required events with integrity controls and real-time monitoring.\"\n"
        f"  }}\n"
        f"]\n\n"
        
        f"Generate 3 criteria for {framework} {control} {subcontrol}.\n"
        f"Return only the JSON array. No explanations."
    )



import json
import re
import logging
from typing import List, Dict, Optional

logger = logging.getLogger(__name__)

async def extract_and_convert_llm_json_criteria_tolist(json_text: str) -> List[str]:
    """
    Production-grade JSON extraction with multi-level error recovery.
    Handles escaped characters, markdown blocks, and malformed JSON.
    """
    if not json_text or json_text.strip() == "":
        logger.warning("Empty JSON text received")
        return []
    
    # Step 1: Clean markdown code blocks
    cleaned = re.sub(r'```(?:json)?\s*|\s*```
    
    # Step 2: Handle literal escaped characters (the core issue from Image 1)
    if '\\n' in cleaned or '\\"' in cleaned:
        logger.info("Detected escaped characters, unescaping...")
        # Replace literal \n with space, \" with "
        cleaned = cleaned.replace('\\n', ' ').replace('\\"', '"').replace('\\\\', '\\')
    
    # Step 3: Try to extract JSON array if embedded in text
    json_match = re.search(r'$$\s*\{.*?\}\s*$$', cleaned, re.DOTALL)
    if json_match:
        cleaned = json_match.group(0)
    
    # Step 4: Attempt parsing with error handling
    try:
        data = json.loads(cleaned)
        
        # Validate structure
        if not isinstance(data, list):
            logger.error(f"Expected list, got {type(data)}")
            return []
        
        # Extract criteria with validation
        criteria_list = []
        for idx, item in enumerate(data):
            if not isinstance(item, dict):
                logger.warning(f"Item {idx} is not a dict, skipping")
                continue
            
            if "criteria" not in item:
                logger.warning(f"Item {idx} missing 'criteria' field")
                continue
            
            criteria_list.append(item["criteria"])
        
        logger.info(f"Successfully extracted {len(criteria_list)} criteria")
        return criteria_list
    
    except json.JSONDecodeError as e:
        logger.error(f"JSON decode failed at position {e.pos}: {e.msg}")
        logger.error(f"Problematic text (first 300 chars): {cleaned[:300]}")
        
        # Recovery attempt: try fixing common JSON errors
        return attempt_json_recovery(cleaned)
    
    except Exception as e:
        logger.exception(f"Unexpected error during JSON extraction: {e}")
        return []


def attempt_json_recovery(malformed_json: str) -> List[str]:
    """
    Attempt to recover from malformed JSON using heuristics.
    """
    logger.info("Attempting JSON recovery...")
    
    try:
        # Strategy 1: Fix unescaped quotes in criteria values
        # Look for patterns like: "criteria": "Text with "nested" quotes"
        fixed = re.sub(
            r'("criteria":\s*")([^"]*?)("(?:[^"]*?)")([^"]*?)(")',
            lambda m: f'{m.group(1)}{m.group(2)}{m.group(3).replace(\'"\', \'\\\\"\')}' \
                      f'{m.group(4)}{m.group(5)}',
            malformed_json
        )
        
        # Strategy 2: Remove trailing commas before closing brackets
        fixed = re.sub(r',(\s*[}$$])', r'\1', fixed)
        
        # Strategy 3: Try parsing again
        data = json.loads(fixed)
        if isinstance(data, list):
            return [item.get("criteria", "") for item in data if isinstance(item, dict)]
    
    except Exception as e:
        logger.warning(f"JSON recovery failed: {e}")
    
    return []

