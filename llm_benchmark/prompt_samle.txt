def get_criteria_prompt(control: str, subcontrol: str, framework: str) -> str:
    return (
        f'Control: {control}\n'
        f'Subcontrol: {subcontrol}\n\n'
        "Generate exactly three evaluation criteria for compliance assessment. "
        "Each criterion must be testable and actionable. "
        "Return ONLY a JSON array of three objects with this schema:\n\n"
        '[\n'
        '  {\n'
        '    "id": 1,                         # integer\n'
        '    "criterion": "short title",     # short sentence\n'
        '    "description": "one-paragraph detailed requirement",\n'
        '    "design_level": "what to look for at design level (short)",\n'
        '    "implementation_level": "what to look for at implementation level (short)",\n'
        '    "evidence_examples": ["e.g. meeting minutes", "e.g. list of parties"]\n'
        '  },\n'
        '  ... (total 3 objects)\n'
        ']\n\n'
        "Do not include any explanation, headings, markdown, or extra text. "
        "Do not output fewer or more than three objects."
    )

async def get_system_prompt(framework: str) -> str:
    """Production-grade system prompt with clear constraints."""
    return (
        f"You are an expert cybersecurity auditor specializing in {framework} compliance assessments.\n\n"
        f"CRITICAL REQUIREMENTS:\n"
        f"1. Output MUST be valid JSON only - no markdown, no explanations, no preamble\n"
        f"2. Output MUST be a JSON array with exactly 3 objects\n"
        f"3. Each object MUST have 'id' (integer) and 'criteria' (string) fields only\n"
        f"4. Write natural, professional language without escaped characters\n"
        f"5. Keep criteria concise: 40-60 words maximum per criterion\n\n"
        f"If you cannot generate valid JSON, return an empty array: []"
    )
async def get_criteria_prompt(control: str, subcontrol: str, framework: str) -> str:
    """Production-optimized prompt with clear structure and example."""
    return (
        f"Framework: {framework}\n"
        f"Control: {control}\n"
        f"Subcontrol: {subcontrol}\n\n"
        f"Task: Generate exactly 3 evaluation criteria for compliance assessment.\n\n"
        f"Structure for each criterion:\n"
        f"- Brief title (3-5 words)\n"
        f"- Core requirement description (1 sentence)\n"
        f"- Design-level check (1 sentence)\n"
        f"- Implementation-level check (1 sentence)\n\n"
        f"Combine all parts into ONE continuous string without labels.\n\n"
        f"EXAMPLE OUTPUT FORMAT:\n"
        f"[\n"
        f"  {{\n"
        f"    \"id\": 1,\n"
        f"    \"criteria\": \"Access Control Matrix - Define role-based permissions for all system resources. Verify comprehensive permission matrix exists in design documentation. Validate actual permissions match design specifications in production environment.\"\n"
        f"  }},\n"
        f"  {{\n"
        f"    \"id\": 2,\n"
        f"    \"criteria\": \"Authentication Mechanisms - Implement multi-factor authentication for privileged access. Review authentication flow diagrams and security architecture. Test MFA implementation across all access points.\"\n"
        f"  }},\n"
        f"  {{\n"
        f"    \"id\": 3,\n"
        f"    \"criteria\": \"Audit Logging Requirements - Maintain immutable audit logs for security events. Confirm logging strategy covers all security-relevant actions. Verify log integrity, retention, and monitoring capabilities.\"\n"
        f"  }}\n"
        f"]\n\n"
        f"Output ONLY the JSON array above with {framework} {control} {subcontrol} criteria. No additional text."
    )

async def get_system_prompt(framework: str) -> str:
    """
    Universal system prompt optimized for all benchmark models.
    Balanced complexity for fair comparison.
    """
    return (
        f"You are an expert cybersecurity compliance auditor specializing in {framework} standards.\n\n"
        f"Your task is to generate compliance evaluation criteria in strict JSON format.\n\n"
        f"OUTPUT REQUIREMENTS:\n"
        f"- Return ONLY a valid JSON array\n"
        f"- No markdown code blocks\n"
        f"- No explanations or additional text\n"
        f"- Each criterion must be clear, measurable, and actionable\n"
        f"- Each criterion must address both design-level and implementation-level verification\n"
    )
async def get_criteria_prompt(control: str, subcontrol: str, framework: str) -> str:
    """
    Universal user prompt for benchmarking all models.
    Optimized for clarity, consistency, and fair evaluation.
    """
    return (
        f"Framework: {framework}\n"
        f"Control: {control}\n"
        f"Subcontrol: {subcontrol}\n\n"
        
        f"Task: Generate exactly 3 compliance evaluation criteria.\n\n"
        
        f"Each criterion must:\n"
        f"1. Be clear and measurable\n"
        f"2. Focus on policy-level compliance (not technical implementation details)\n"
        f"3. Include a brief title (3-5 words)\n"
        f"4. State the core requirement\n"
        f"5. Specify design-level verification (what to check in documentation/plans)\n"
        f"6. Specify implementation-level verification (what to check in production systems)\n\n"
        
        f"Combine all parts into ONE continuous sentence per criterion.\n\n"
        
        f"EXAMPLE OUTPUT:\n"
        f"[\n"
        f"  {{\n"
        f"    \"id\": 1,\n"
        f"    \"criteria\": \"Access Control Matrix - Define comprehensive role-based permissions for all system resources. Verify that design documentation includes detailed permission matrix with role definitions. Validate that production systems enforce the defined permissions with quarterly access reviews.\"\n"
        f"  }},\n"
        f"  {{\n"
        f"    \"id\": 2,\n"
        f"    \"criteria\": \"Multi-Factor Authentication Policy - Implement MFA for all privileged accounts and remote access. Confirm that security architecture specifies MFA mechanisms and enrollment procedures. Verify MFA is configured on all access points with monitoring for authentication anomalies.\"\n"
        f"  }},\n"
        f"  {{\n"
        f"    \"id\": 3,\n"
        f"    \"criteria\": \"Security Audit Logging - Maintain comprehensive tamper-evident logs for all security events. Review logging strategy documentation covering log sources and retention requirements. Validate production logging captures required events with integrity controls and real-time monitoring.\"\n"
        f"  }}\n"
        f"]\n\n"
        
        f"Generate 3 criteria for {framework} {control} {subcontrol}.\n"
        f"Return only the JSON array. No explanations."
    )



import json
import re
import logging
from typing import List

logger = logging.getLogger(__name__)

async def extract_and_convert_llm_json_criteria_tolist(json_text: str) -> List[str]:
    """
    Robustly extract 'criteria' fields from LLM JSON output, handling escaped characters,
    markdown blocks, and most common malformed outputs. Returns a list of criteria strings.
    """
    if not json_text or json_text.strip() == "":
        logger.warning("Empty JSON text received")
        return []
    
    # Step 1: Remove markdown code blocks if present
    cleaned = re.sub(r'``````', '', json_text.strip())
    
    # Step 2: Handle literal escaped characters
    if '\\n' in cleaned or '\\"' in cleaned or '\\\\' in cleaned:
        logger.info("Detected escaped characters in output, unescaping...")
        cleaned = cleaned.replace('\\n', ' ').replace('\\"', '"').replace('\\\\', '\\')
    
    # Step 3: Try extracting JSON array (in case output has leading/trailing text)
    json_match = re.search(r'\[\s*\{.*?\}\s*\]', cleaned, re.DOTALL)
    if json_match:
        cleaned = json_match.group(0)
    
    # Step 4: Try loading via json.loads, with error handling
    try:
        data = json.loads(cleaned)
        # Validate expected structure
        if not isinstance(data, list):
            logger.error(f"Expected a JSON list/array, got: {type(data)}")
            return []
        
        criteria_list = []
        for idx, item in enumerate(data):
            if not isinstance(item, dict):
                logger.warning(f"Item {idx} is not a dict: {item}")
                continue
            if "criteria" not in item:
                logger.warning(f"Item {idx} missing 'criteria': {item}")
                continue
            criteria_list.append(item["criteria"])
        logger.info(f"Successfully extracted {len(criteria_list)} criteria")
        return criteria_list

    except json.JSONDecodeError as e:
        logger.error(f"JSONDecodeError: {e.msg} at pos {e.pos}. Attempting recovery...")
        return attempt_json_recovery(cleaned)
    except Exception as e:
        logger.exception(f"Unexpected error during JSON extraction: {e}")
        return []

def attempt_json_recovery(malformed_json: str) -> List[str]:
    """
    Attempt to recover criteria from malformed JSON produced by LLMs.
    Common issues handled: trailing commas, unescaped quotes,
    embedded newlines, or partial/incomplete arrays/objects.
    """
    logger.info("Attempting recovery for malformed LLM JSON output...")

    # Fix 1: Remove trailing commas before closing brackets/braces
    fixed = re.sub(r',\s*([}\]])', r'\1', malformed_json)

    # Fix 2: Remove lone newlines and redundant whitespace between objects
    fixed = re.sub(r'\n+', ' ', fixed).strip()
    
    # Fix 3: Try to extract dicts using a looser match (find all dict-like substrings and parse)
    dict_matches = re.findall(r'\{[^\}]+\}', fixed)
    criteria_list = []
    for idx, dm in enumerate(dict_matches):
        try:
            # Add braces if needed
            candidate = dm.strip()
            if not candidate.startswith('{'):
                candidate = '{' + candidate
            if not candidate.endswith('}'):
                candidate = candidate + '}'
            # Replace single quotes with double quotes for JSON validity
            candidate = candidate.replace("'", '"')
            # Remove trailing comma if present
            candidate = re.sub(r',\s*}', '}', candidate)
            d = json.loads(candidate)
            if isinstance(d, dict) and "criteria" in d:
                criteria_list.append(d["criteria"])
        except Exception as e:
            logger.warning(f"Partial recovery failed for dict {idx}: {e}")
            continue
    if criteria_list:
        logger.info(f"Recovered {len(criteria_list)} criteria from malformed output.")
        return criteria_list

    logger.error("Recovery failed: Could not extract criteria from malformed JSON output.")
    return []


